// Generated by Molecule 0.7.2

use molecule :: prelude :: * ;
use super :: basic :: * ;
# [derive (Clone)] pub struct Validator (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Validator { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Validator { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Validator { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "bls_pub_key" , self . bls_pub_key ()) ? ; write ! (f , ", {}: {}" , "pub_key" , self . pub_key ()) ? ; write ! (f , ", {}: {}" , "address" , self . address ()) ? ; write ! (f , ", {}: {}" , "propose_weight" , self . propose_weight ()) ? ; write ! (f , ", {}: {}" , "vote_weight" , self . vote_weight ()) ? ; write ! (f , ", {}: {}" , "propose_count" , self . propose_count ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for Validator { fn default () -> Self { let v : Vec < u8 > = vec ! [161 , 0 , 0 , 0 , 28 , 0 , 0 , 0 , 125 , 0 , 0 , 0 , 129 , 0 , 0 , 0 , 149 , 0 , 0 , 0 , 153 , 0 , 0 , 0 , 157 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; Validator :: new_unchecked (v . into ()) } } impl Validator { pub const FIELD_COUNT : usize = 6 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn bls_pub_key (& self) -> Byte97 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte97 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn pub_key (& self) -> Bytes { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Bytes :: new_unchecked (self . 0 . slice (start .. end)) } pub fn address (& self) -> Identity { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Identity :: new_unchecked (self . 0 . slice (start .. end)) } pub fn propose_weight (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn vote_weight (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn propose_count (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } else { Byte4 :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> ValidatorReader < 'r > { ValidatorReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Validator { type Builder = ValidatorBuilder ; const NAME : & 'static str = "Validator" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Validator (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ValidatorReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ValidatorReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . bls_pub_key (self . bls_pub_key ()) . pub_key (self . pub_key ()) . address (self . address ()) . propose_weight (self . propose_weight ()) . vote_weight (self . vote_weight ()) . propose_count (self . propose_count ()) } }
# [derive (Clone , Copy)] pub struct ValidatorReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ValidatorReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ValidatorReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ValidatorReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "bls_pub_key" , self . bls_pub_key ()) ? ; write ! (f , ", {}: {}" , "pub_key" , self . pub_key ()) ? ; write ! (f , ", {}: {}" , "address" , self . address ()) ? ; write ! (f , ", {}: {}" , "propose_weight" , self . propose_weight ()) ? ; write ! (f , ", {}: {}" , "vote_weight" , self . vote_weight ()) ? ; write ! (f , ", {}: {}" , "propose_count" , self . propose_count ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > ValidatorReader < 'r > { pub const FIELD_COUNT : usize = 6 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn bls_pub_key (& self) -> Byte97Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte97Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn pub_key (& self) -> BytesReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; BytesReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn address (& self) -> IdentityReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; IdentityReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn propose_weight (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn vote_weight (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn propose_count (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } else { Byte4Reader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ValidatorReader < 'r > { type Entity = Validator ; const NAME : & 'static str = "ValidatorReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ValidatorReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE && Self :: FIELD_COUNT == 0 { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Byte97Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; BytesReader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; IdentityReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [5] .. offsets [6]] , compatible) ? ; Ok (()) } }
# [derive (Debug , Default)] pub struct ValidatorBuilder { pub (crate) bls_pub_key : Byte97 , pub (crate) pub_key : Bytes , pub (crate) address : Identity , pub (crate) propose_weight : Byte4 , pub (crate) vote_weight : Byte4 , pub (crate) propose_count : Byte4 , } impl ValidatorBuilder { pub const FIELD_COUNT : usize = 6 ; pub fn bls_pub_key (mut self , v : Byte97) -> Self { self . bls_pub_key = v ; self } pub fn pub_key (mut self , v : Bytes) -> Self { self . pub_key = v ; self } pub fn address (mut self , v : Identity) -> Self { self . address = v ; self } pub fn propose_weight (mut self , v : Byte4) -> Self { self . propose_weight = v ; self } pub fn vote_weight (mut self , v : Byte4) -> Self { self . vote_weight = v ; self } pub fn propose_count (mut self , v : Byte4) -> Self { self . propose_count = v ; self } } impl molecule :: prelude :: Builder for ValidatorBuilder { type Entity = Validator ; const NAME : & 'static str = "ValidatorBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . bls_pub_key . as_slice () . len () + self . pub_key . as_slice () . len () + self . address . as_slice () . len () + self . propose_weight . as_slice () . len () + self . vote_weight . as_slice () . len () + self . propose_count . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . bls_pub_key . as_slice () . len () ; offsets . push (total_size) ; total_size += self . pub_key . as_slice () . len () ; offsets . push (total_size) ; total_size += self . address . as_slice () . len () ; offsets . push (total_size) ; total_size += self . propose_weight . as_slice () . len () ; offsets . push (total_size) ; total_size += self . vote_weight . as_slice () . len () ; offsets . push (total_size) ; total_size += self . propose_count . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . bls_pub_key . as_slice ()) ? ; writer . write_all (self . pub_key . as_slice ()) ? ; writer . write_all (self . address . as_slice ()) ? ; writer . write_all (self . propose_weight . as_slice ()) ? ; writer . write_all (self . vote_weight . as_slice ()) ? ; writer . write_all (self . propose_count . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Validator :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct ValidatorHistory (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ValidatorHistory { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ValidatorHistory { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ValidatorHistory { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "address" , self . address ()) ? ; write ! (f , ", {}: {}" , "propose_count" , self . propose_count ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for ValidatorHistory { fn default () -> Self { let v : Vec < u8 > = vec ! [36 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 32 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; ValidatorHistory :: new_unchecked (v . into ()) } } impl ValidatorHistory { pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn address (& self) -> Identity { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Identity :: new_unchecked (self . 0 . slice (start .. end)) } pub fn propose_count (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } else { Byte4 :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> ValidatorHistoryReader < 'r > { ValidatorHistoryReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ValidatorHistory { type Builder = ValidatorHistoryBuilder ; const NAME : & 'static str = "ValidatorHistory" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ValidatorHistory (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ValidatorHistoryReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ValidatorHistoryReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . address (self . address ()) . propose_count (self . propose_count ()) } }
# [derive (Clone , Copy)] pub struct ValidatorHistoryReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ValidatorHistoryReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ValidatorHistoryReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ValidatorHistoryReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "address" , self . address ()) ? ; write ! (f , ", {}: {}" , "propose_count" , self . propose_count ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > ValidatorHistoryReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn address (& self) -> IdentityReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; IdentityReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn propose_count (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } else { Byte4Reader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ValidatorHistoryReader < 'r > { type Entity = ValidatorHistory ; const NAME : & 'static str = "ValidatorHistoryReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ValidatorHistoryReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE && Self :: FIELD_COUNT == 0 { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } IdentityReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Ok (()) } }
# [derive (Debug , Default)] pub struct ValidatorHistoryBuilder { pub (crate) address : Identity , pub (crate) propose_count : Byte4 , } impl ValidatorHistoryBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn address (mut self , v : Identity) -> Self { self . address = v ; self } pub fn propose_count (mut self , v : Byte4) -> Self { self . propose_count = v ; self } } impl molecule :: prelude :: Builder for ValidatorHistoryBuilder { type Entity = ValidatorHistory ; const NAME : & 'static str = "ValidatorHistoryBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . address . as_slice () . len () + self . propose_count . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . address . as_slice () . len () ; offsets . push (total_size) ; total_size += self . propose_count . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . address . as_slice ()) ? ; writer . write_all (self . propose_count . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ValidatorHistory :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct MetadataList (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for MetadataList { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for MetadataList { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for MetadataList { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for MetadataList { fn default () -> Self { let v : Vec < u8 > = vec ! [4 , 0 , 0 , 0 ,] ; MetadataList :: new_unchecked (v . into ()) } } impl MetadataList { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Metadata > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Metadata { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { Metadata :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; Metadata :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> MetadataListReader < 'r > { MetadataListReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for MetadataList { type Builder = MetadataListBuilder ; const NAME : & 'static str = "MetadataList" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { MetadataList (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { MetadataListReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { MetadataListReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct MetadataListReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for MetadataListReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for MetadataListReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for MetadataListReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > MetadataListReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < MetadataReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> MetadataReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { MetadataReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; MetadataReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for MetadataListReader < 'r > { type Entity = MetadataList ; const NAME : & 'static str = "MetadataListReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { MetadataListReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; MetadataReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Debug , Default)] pub struct MetadataListBuilder (pub (crate) Vec < Metadata >) ; impl MetadataListBuilder { pub fn set (mut self , v : Vec < Metadata >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : Metadata) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Metadata >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } } impl molecule :: prelude :: Builder for MetadataListBuilder { type Entity = MetadataList ; const NAME : & 'static str = "MetadataListBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; MetadataList :: new_unchecked (inner . into ()) } }
pub struct MetadataListIterator (MetadataList , usize , usize) ; impl :: core :: iter :: Iterator for MetadataListIterator { type Item = Metadata ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for MetadataListIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for MetadataList { type Item = Metadata ; type IntoIter = MetadataListIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; MetadataListIterator (self , 0 , len) } } impl < 'r > MetadataListReader < 'r > { pub fn iter < 't > (& 't self) -> MetadataListReaderIterator < 't , 'r > { MetadataListReaderIterator (& self , 0 , self . len ()) } } pub struct MetadataListReaderIterator < 't , 'r > (& 't MetadataListReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for MetadataListReaderIterator < 't , 'r > { type Item = MetadataReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for MetadataListReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
# [derive (Clone)] pub struct ValidatorList (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ValidatorList { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ValidatorList { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ValidatorList { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for ValidatorList { fn default () -> Self { let v : Vec < u8 > = vec ! [4 , 0 , 0 , 0 ,] ; ValidatorList :: new_unchecked (v . into ()) } } impl ValidatorList { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Validator > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Validator { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { Validator :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; Validator :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> ValidatorListReader < 'r > { ValidatorListReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ValidatorList { type Builder = ValidatorListBuilder ; const NAME : & 'static str = "ValidatorList" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ValidatorList (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ValidatorListReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ValidatorListReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct ValidatorListReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ValidatorListReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ValidatorListReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ValidatorListReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > ValidatorListReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ValidatorReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ValidatorReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { ValidatorReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; ValidatorReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ValidatorListReader < 'r > { type Entity = ValidatorList ; const NAME : & 'static str = "ValidatorListReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ValidatorListReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; ValidatorReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Debug , Default)] pub struct ValidatorListBuilder (pub (crate) Vec < Validator >) ; impl ValidatorListBuilder { pub fn set (mut self , v : Vec < Validator >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : Validator) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Validator >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } } impl molecule :: prelude :: Builder for ValidatorListBuilder { type Entity = ValidatorList ; const NAME : & 'static str = "ValidatorListBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ValidatorList :: new_unchecked (inner . into ()) } }
pub struct ValidatorListIterator (ValidatorList , usize , usize) ; impl :: core :: iter :: Iterator for ValidatorListIterator { type Item = Validator ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for ValidatorListIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for ValidatorList { type Item = Validator ; type IntoIter = ValidatorListIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; ValidatorListIterator (self , 0 , len) } } impl < 'r > ValidatorListReader < 'r > { pub fn iter < 't > (& 't self) -> ValidatorListReaderIterator < 't , 'r > { ValidatorListReaderIterator (& self , 0 , self . len ()) } } pub struct ValidatorListReaderIterator < 't , 'r > (& 't ValidatorListReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for ValidatorListReaderIterator < 't , 'r > { type Item = ValidatorReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for ValidatorListReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
# [derive (Clone)] pub struct ValidatorHistoryList (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for ValidatorHistoryList { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for ValidatorHistoryList { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for ValidatorHistoryList { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for ValidatorHistoryList { fn default () -> Self { let v : Vec < u8 > = vec ! [4 , 0 , 0 , 0 ,] ; ValidatorHistoryList :: new_unchecked (v . into ()) } } impl ValidatorHistoryList { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ValidatorHistory > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ValidatorHistory { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { ValidatorHistory :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; ValidatorHistory :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> ValidatorHistoryListReader < 'r > { ValidatorHistoryListReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for ValidatorHistoryList { type Builder = ValidatorHistoryListBuilder ; const NAME : & 'static str = "ValidatorHistoryList" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { ValidatorHistoryList (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ValidatorHistoryListReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { ValidatorHistoryListReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct ValidatorHistoryListReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for ValidatorHistoryListReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for ValidatorHistoryListReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for ValidatorHistoryListReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > ValidatorHistoryListReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ValidatorHistoryReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ValidatorHistoryReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { ValidatorHistoryReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; ValidatorHistoryReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ValidatorHistoryListReader < 'r > { type Entity = ValidatorHistoryList ; const NAME : & 'static str = "ValidatorHistoryListReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { ValidatorHistoryListReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; ValidatorHistoryReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Debug , Default)] pub struct ValidatorHistoryListBuilder (pub (crate) Vec < ValidatorHistory >) ; impl ValidatorHistoryListBuilder { pub fn set (mut self , v : Vec < ValidatorHistory >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : ValidatorHistory) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = ValidatorHistory >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } } impl molecule :: prelude :: Builder for ValidatorHistoryListBuilder { type Entity = ValidatorHistoryList ; const NAME : & 'static str = "ValidatorHistoryListBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; ValidatorHistoryList :: new_unchecked (inner . into ()) } }
pub struct ValidatorHistoryListIterator (ValidatorHistoryList , usize , usize) ; impl :: core :: iter :: Iterator for ValidatorHistoryListIterator { type Item = ValidatorHistory ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for ValidatorHistoryListIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for ValidatorHistoryList { type Item = ValidatorHistory ; type IntoIter = ValidatorHistoryListIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; ValidatorHistoryListIterator (self , 0 , len) } } impl < 'r > ValidatorHistoryListReader < 'r > { pub fn iter < 't > (& 't self) -> ValidatorHistoryListReaderIterator < 't , 'r > { ValidatorHistoryListReaderIterator (& self , 0 , self . len ()) } } pub struct ValidatorHistoryListReaderIterator < 't , 'r > (& 't ValidatorHistoryListReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for ValidatorHistoryListReaderIterator < 't , 'r > { type Item = ValidatorHistoryReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for ValidatorHistoryListReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
# [derive (Clone)] pub struct Metadata (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Metadata { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Metadata { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Metadata { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "epoch_len" , self . epoch_len ()) ? ; write ! (f , ", {}: {}" , "period_len" , self . period_len ()) ? ; write ! (f , ", {}: {}" , "quorum" , self . quorum ()) ? ; write ! (f , ", {}: {}" , "gas_limit" , self . gas_limit ()) ? ; write ! (f , ", {}: {}" , "gas_price" , self . gas_price ()) ? ; write ! (f , ", {}: {}" , "interval" , self . interval ()) ? ; write ! (f , ", {}: {}" , "validators" , self . validators ()) ? ; write ! (f , ", {}: {}" , "propose_ratio" , self . propose_ratio ()) ? ; write ! (f , ", {}: {}" , "prevote_ratio" , self . prevote_ratio ()) ? ; write ! (f , ", {}: {}" , "precommit_ratio" , self . precommit_ratio ()) ? ; write ! (f , ", {}: {}" , "brake_ratio" , self . brake_ratio ()) ? ; write ! (f , ", {}: {}" , "tx_num_limit" , self . tx_num_limit ()) ? ; write ! (f , ", {}: {}" , "max_tx_size" , self . max_tx_size ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for Metadata { fn default () -> Self { let v : Vec < u8 > = vec ! [120 , 0 , 0 , 0 , 56 , 0 , 0 , 0 , 64 , 0 , 0 , 0 , 68 , 0 , 0 , 0 , 72 , 0 , 0 , 0 , 80 , 0 , 0 , 0 , 88 , 0 , 0 , 0 , 92 , 0 , 0 , 0 , 96 , 0 , 0 , 0 , 100 , 0 , 0 , 0 , 104 , 0 , 0 , 0 , 108 , 0 , 0 , 0 , 112 , 0 , 0 , 0 , 116 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; Metadata :: new_unchecked (v . into ()) } } impl Metadata { pub const FIELD_COUNT : usize = 13 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn epoch_len (& self) -> Byte8 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte8 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn period_len (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn quorum (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn gas_limit (& self) -> Byte8 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Byte8 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn gas_price (& self) -> Byte8 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Byte8 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn interval (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn validators (& self) -> ValidatorList { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [28 ..]) as usize ; let end = molecule :: unpack_number (& slice [32 ..]) as usize ; ValidatorList :: new_unchecked (self . 0 . slice (start .. end)) } pub fn propose_ratio (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [32 ..]) as usize ; let end = molecule :: unpack_number (& slice [36 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn prevote_ratio (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [36 ..]) as usize ; let end = molecule :: unpack_number (& slice [40 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn precommit_ratio (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [40 ..]) as usize ; let end = molecule :: unpack_number (& slice [44 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn brake_ratio (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [44 ..]) as usize ; let end = molecule :: unpack_number (& slice [48 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn tx_num_limit (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [48 ..]) as usize ; let end = molecule :: unpack_number (& slice [52 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn max_tx_size (& self) -> Byte4 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [52 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [56 ..]) as usize ; Byte4 :: new_unchecked (self . 0 . slice (start .. end)) } else { Byte4 :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> MetadataReader < 'r > { MetadataReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Metadata { type Builder = MetadataBuilder ; const NAME : & 'static str = "Metadata" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Metadata (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { MetadataReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { MetadataReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . epoch_len (self . epoch_len ()) . period_len (self . period_len ()) . quorum (self . quorum ()) . gas_limit (self . gas_limit ()) . gas_price (self . gas_price ()) . interval (self . interval ()) . validators (self . validators ()) . propose_ratio (self . propose_ratio ()) . prevote_ratio (self . prevote_ratio ()) . precommit_ratio (self . precommit_ratio ()) . brake_ratio (self . brake_ratio ()) . tx_num_limit (self . tx_num_limit ()) . max_tx_size (self . max_tx_size ()) } }
# [derive (Clone , Copy)] pub struct MetadataReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for MetadataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for MetadataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for MetadataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "epoch_len" , self . epoch_len ()) ? ; write ! (f , ", {}: {}" , "period_len" , self . period_len ()) ? ; write ! (f , ", {}: {}" , "quorum" , self . quorum ()) ? ; write ! (f , ", {}: {}" , "gas_limit" , self . gas_limit ()) ? ; write ! (f , ", {}: {}" , "gas_price" , self . gas_price ()) ? ; write ! (f , ", {}: {}" , "interval" , self . interval ()) ? ; write ! (f , ", {}: {}" , "validators" , self . validators ()) ? ; write ! (f , ", {}: {}" , "propose_ratio" , self . propose_ratio ()) ? ; write ! (f , ", {}: {}" , "prevote_ratio" , self . prevote_ratio ()) ? ; write ! (f , ", {}: {}" , "precommit_ratio" , self . precommit_ratio ()) ? ; write ! (f , ", {}: {}" , "brake_ratio" , self . brake_ratio ()) ? ; write ! (f , ", {}: {}" , "tx_num_limit" , self . tx_num_limit ()) ? ; write ! (f , ", {}: {}" , "max_tx_size" , self . max_tx_size ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > MetadataReader < 'r > { pub const FIELD_COUNT : usize = 13 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn epoch_len (& self) -> Byte8Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte8Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn period_len (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn quorum (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn gas_limit (& self) -> Byte8Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; let end = molecule :: unpack_number (& slice [20 ..]) as usize ; Byte8Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn gas_price (& self) -> Byte8Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [20 ..]) as usize ; let end = molecule :: unpack_number (& slice [24 ..]) as usize ; Byte8Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn interval (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [24 ..]) as usize ; let end = molecule :: unpack_number (& slice [28 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn validators (& self) -> ValidatorListReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [28 ..]) as usize ; let end = molecule :: unpack_number (& slice [32 ..]) as usize ; ValidatorListReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn propose_ratio (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [32 ..]) as usize ; let end = molecule :: unpack_number (& slice [36 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn prevote_ratio (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [36 ..]) as usize ; let end = molecule :: unpack_number (& slice [40 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn precommit_ratio (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [40 ..]) as usize ; let end = molecule :: unpack_number (& slice [44 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn brake_ratio (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [44 ..]) as usize ; let end = molecule :: unpack_number (& slice [48 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn tx_num_limit (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [48 ..]) as usize ; let end = molecule :: unpack_number (& slice [52 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn max_tx_size (& self) -> Byte4Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [52 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [56 ..]) as usize ; Byte4Reader :: new_unchecked (& self . as_slice () [start .. end]) } else { Byte4Reader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for MetadataReader < 'r > { type Entity = Metadata ; const NAME : & 'static str = "MetadataReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { MetadataReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE && Self :: FIELD_COUNT == 0 { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } Byte8Reader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; Byte8Reader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Byte8Reader :: verify (& slice [offsets [4] .. offsets [5]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [5] .. offsets [6]] , compatible) ? ; ValidatorListReader :: verify (& slice [offsets [6] .. offsets [7]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [7] .. offsets [8]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [8] .. offsets [9]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [9] .. offsets [10]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [10] .. offsets [11]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [11] .. offsets [12]] , compatible) ? ; Byte4Reader :: verify (& slice [offsets [12] .. offsets [13]] , compatible) ? ; Ok (()) } }
# [derive (Debug , Default)] pub struct MetadataBuilder { pub (crate) epoch_len : Byte8 , pub (crate) period_len : Byte4 , pub (crate) quorum : Byte4 , pub (crate) gas_limit : Byte8 , pub (crate) gas_price : Byte8 , pub (crate) interval : Byte4 , pub (crate) validators : ValidatorList , pub (crate) propose_ratio : Byte4 , pub (crate) prevote_ratio : Byte4 , pub (crate) precommit_ratio : Byte4 , pub (crate) brake_ratio : Byte4 , pub (crate) tx_num_limit : Byte4 , pub (crate) max_tx_size : Byte4 , } impl MetadataBuilder { pub const FIELD_COUNT : usize = 13 ; pub fn epoch_len (mut self , v : Byte8) -> Self { self . epoch_len = v ; self } pub fn period_len (mut self , v : Byte4) -> Self { self . period_len = v ; self } pub fn quorum (mut self , v : Byte4) -> Self { self . quorum = v ; self } pub fn gas_limit (mut self , v : Byte8) -> Self { self . gas_limit = v ; self } pub fn gas_price (mut self , v : Byte8) -> Self { self . gas_price = v ; self } pub fn interval (mut self , v : Byte4) -> Self { self . interval = v ; self } pub fn validators (mut self , v : ValidatorList) -> Self { self . validators = v ; self } pub fn propose_ratio (mut self , v : Byte4) -> Self { self . propose_ratio = v ; self } pub fn prevote_ratio (mut self , v : Byte4) -> Self { self . prevote_ratio = v ; self } pub fn precommit_ratio (mut self , v : Byte4) -> Self { self . precommit_ratio = v ; self } pub fn brake_ratio (mut self , v : Byte4) -> Self { self . brake_ratio = v ; self } pub fn tx_num_limit (mut self , v : Byte4) -> Self { self . tx_num_limit = v ; self } pub fn max_tx_size (mut self , v : Byte4) -> Self { self . max_tx_size = v ; self } } impl molecule :: prelude :: Builder for MetadataBuilder { type Entity = Metadata ; const NAME : & 'static str = "MetadataBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . epoch_len . as_slice () . len () + self . period_len . as_slice () . len () + self . quorum . as_slice () . len () + self . gas_limit . as_slice () . len () + self . gas_price . as_slice () . len () + self . interval . as_slice () . len () + self . validators . as_slice () . len () + self . propose_ratio . as_slice () . len () + self . prevote_ratio . as_slice () . len () + self . precommit_ratio . as_slice () . len () + self . brake_ratio . as_slice () . len () + self . tx_num_limit . as_slice () . len () + self . max_tx_size . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . epoch_len . as_slice () . len () ; offsets . push (total_size) ; total_size += self . period_len . as_slice () . len () ; offsets . push (total_size) ; total_size += self . quorum . as_slice () . len () ; offsets . push (total_size) ; total_size += self . gas_limit . as_slice () . len () ; offsets . push (total_size) ; total_size += self . gas_price . as_slice () . len () ; offsets . push (total_size) ; total_size += self . interval . as_slice () . len () ; offsets . push (total_size) ; total_size += self . validators . as_slice () . len () ; offsets . push (total_size) ; total_size += self . propose_ratio . as_slice () . len () ; offsets . push (total_size) ; total_size += self . prevote_ratio . as_slice () . len () ; offsets . push (total_size) ; total_size += self . precommit_ratio . as_slice () . len () ; offsets . push (total_size) ; total_size += self . brake_ratio . as_slice () . len () ; offsets . push (total_size) ; total_size += self . tx_num_limit . as_slice () . len () ; offsets . push (total_size) ; total_size += self . max_tx_size . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . epoch_len . as_slice ()) ? ; writer . write_all (self . period_len . as_slice ()) ? ; writer . write_all (self . quorum . as_slice ()) ? ; writer . write_all (self . gas_limit . as_slice ()) ? ; writer . write_all (self . gas_price . as_slice ()) ? ; writer . write_all (self . interval . as_slice ()) ? ; writer . write_all (self . validators . as_slice ()) ? ; writer . write_all (self . propose_ratio . as_slice ()) ? ; writer . write_all (self . prevote_ratio . as_slice ()) ? ; writer . write_all (self . precommit_ratio . as_slice ()) ? ; writer . write_all (self . brake_ratio . as_slice ()) ? ; writer . write_all (self . tx_num_limit . as_slice ()) ? ; writer . write_all (self . max_tx_size . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Metadata :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct MetadataCellData (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for MetadataCellData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for MetadataCellData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for MetadataCellData { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "version" , self . version ()) ? ; write ! (f , ", {}: {}" , "epoch" , self . epoch ()) ? ; write ! (f , ", {}: {}" , "metadata" , self . metadata ()) ? ; write ! (f , ", {}: {}" , "validators_history" , self . validators_history ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl :: core :: default :: Default for MetadataCellData { fn default () -> Self { let v : Vec < u8 > = vec ! [37 , 0 , 0 , 0 , 20 , 0 , 0 , 0 , 21 , 0 , 0 , 0 , 29 , 0 , 0 , 0 , 33 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 ,] ; MetadataCellData :: new_unchecked (v . into ()) } } impl MetadataCellData { pub const FIELD_COUNT : usize = 4 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn version (& self) -> Byte { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; Byte :: new_unchecked (self . 0 . slice (start .. end)) } pub fn epoch (& self) -> Byte8 { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte8 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn metadata (& self) -> MetadataList { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; MetadataList :: new_unchecked (self . 0 . slice (start .. end)) } pub fn validators_history (& self) -> ValidatorHistoryList { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [20 ..]) as usize ; ValidatorHistoryList :: new_unchecked (self . 0 . slice (start .. end)) } else { ValidatorHistoryList :: new_unchecked (self . 0 . slice (start ..)) } } pub fn as_reader < 'r > (& 'r self) -> MetadataCellDataReader < 'r > { MetadataCellDataReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for MetadataCellData { type Builder = MetadataCellDataBuilder ; const NAME : & 'static str = "MetadataCellData" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { MetadataCellData (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { MetadataCellDataReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { MetadataCellDataReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . version (self . version ()) . epoch (self . epoch ()) . metadata (self . metadata ()) . validators_history (self . validators_history ()) } }
# [derive (Clone , Copy)] pub struct MetadataCellDataReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for MetadataCellDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for MetadataCellDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for MetadataCellDataReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "version" , self . version ()) ? ; write ! (f , ", {}: {}" , "epoch" , self . epoch ()) ? ; write ! (f , ", {}: {}" , "metadata" , self . metadata ()) ? ; write ! (f , ", {}: {}" , "validators_history" , self . validators_history ()) ? ; let extra_count = self . count_extra_fields () ; if extra_count != 0 { write ! (f , ", .. ({} fields)" , extra_count) ? ; } write ! (f , " }}") } } impl < 'r > MetadataCellDataReader < 'r > { pub const FIELD_COUNT : usize = 4 ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn field_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn count_extra_fields (& self) -> usize { self . field_count () - Self :: FIELD_COUNT } pub fn has_extra_fields (& self) -> bool { Self :: FIELD_COUNT != self . field_count () } pub fn version (& self) -> ByteReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [4 ..]) as usize ; let end = molecule :: unpack_number (& slice [8 ..]) as usize ; ByteReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn epoch (& self) -> Byte8Reader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [8 ..]) as usize ; let end = molecule :: unpack_number (& slice [12 ..]) as usize ; Byte8Reader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn metadata (& self) -> MetadataListReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [12 ..]) as usize ; let end = molecule :: unpack_number (& slice [16 ..]) as usize ; MetadataListReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn validators_history (& self) -> ValidatorHistoryListReader < 'r > { let slice = self . as_slice () ; let start = molecule :: unpack_number (& slice [16 ..]) as usize ; if self . has_extra_fields () { let end = molecule :: unpack_number (& slice [20 ..]) as usize ; ValidatorHistoryListReader :: new_unchecked (& self . as_slice () [start .. end]) } else { ValidatorHistoryListReader :: new_unchecked (& self . as_slice () [start ..]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for MetadataCellDataReader < 'r > { type Entity = MetadataCellData ; const NAME : & 'static str = "MetadataCellDataReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { MetadataCellDataReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE && Self :: FIELD_COUNT == 0 { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let field_count = offset_first / molecule :: NUMBER_SIZE - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! (Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count) ; } ; let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } ByteReader :: verify (& slice [offsets [0] .. offsets [1]] , compatible) ? ; Byte8Reader :: verify (& slice [offsets [1] .. offsets [2]] , compatible) ? ; MetadataListReader :: verify (& slice [offsets [2] .. offsets [3]] , compatible) ? ; ValidatorHistoryListReader :: verify (& slice [offsets [3] .. offsets [4]] , compatible) ? ; Ok (()) } }
# [derive (Debug , Default)] pub struct MetadataCellDataBuilder { pub (crate) version : Byte , pub (crate) epoch : Byte8 , pub (crate) metadata : MetadataList , pub (crate) validators_history : ValidatorHistoryList , } impl MetadataCellDataBuilder { pub const FIELD_COUNT : usize = 4 ; pub fn version (mut self , v : Byte) -> Self { self . version = v ; self } pub fn epoch (mut self , v : Byte8) -> Self { self . epoch = v ; self } pub fn metadata (mut self , v : MetadataList) -> Self { self . metadata = v ; self } pub fn validators_history (mut self , v : ValidatorHistoryList) -> Self { self . validators_history = v ; self } } impl molecule :: prelude :: Builder for MetadataCellDataBuilder { type Entity = MetadataCellData ; const NAME : & 'static str = "MetadataCellDataBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) + self . version . as_slice () . len () + self . epoch . as_slice () . len () + self . metadata . as_slice () . len () + self . validators_history . as_slice () . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let mut total_size = molecule :: NUMBER_SIZE * (Self :: FIELD_COUNT + 1) ; let mut offsets = Vec :: with_capacity (Self :: FIELD_COUNT) ; offsets . push (total_size) ; total_size += self . version . as_slice () . len () ; offsets . push (total_size) ; total_size += self . epoch . as_slice () . len () ; offsets . push (total_size) ; total_size += self . metadata . as_slice () . len () ; offsets . push (total_size) ; total_size += self . validators_history . as_slice () . len () ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } writer . write_all (self . version . as_slice ()) ? ; writer . write_all (self . epoch . as_slice ()) ? ; writer . write_all (self . metadata . as_slice ()) ? ; writer . write_all (self . validators_history . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; MetadataCellData :: new_unchecked (inner . into ()) } }
